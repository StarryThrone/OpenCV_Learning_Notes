//
//  main.cpp
//  Subtractor
//
//  Created by chenjie on 2020/9/11.
//  Copyright © 2020 chenjie. All rights reserved.
//

#include <iostream>
#include <opencv2/core.hpp>
#include <opencv2/video.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>

// Global variables
// Current frame
cv::Mat frame;
// Foreground mask generated by MOG2 method
cv::Mat fgMaskMOG2;
// Current background image as seen from the model
cv::Mat theBackground;

//MOG2 Background subtractor
cv::Ptr<cv::BackgroundSubtractor> pMOG2;
//input from keyboard
int keyboard;
void help();
void processVideo(char* videoFilename, int train);
void processImages(char* firstFrameFilename, int train);



void help() {
    std::cout << "\n-----------Taken from tutorial_background_subtraction.html---------------\n" << std::endl
              << "This program shows how to use background subtraction methods provided by" << std::endl
              << "OpenCV (BackgroundSubtractor class)." << std::endl
              << "You can process both videos (-vid) and images (-img)." << std::endl
              << "We pass it #framesTraining which is the number of frames or images to train on before starting background subtraction\n" << std::endl
              << "Usage:" << std::endl
              << "./Subtractor {<#framesTraining> -vid <video filename>|-img <image filename>}\n" << std::endl
              << "for example: ./Subtractor 50 -vid ../tree.avi" << std::endl
              << "or: ./Subtractor 20 -img /data/images/1.png" << std::endl
              << "\n" << std::endl
              << "This file demonstrates the MOG2 class, you can go to opencv docs to see" << std::endl
              << "other techniques. Each technique has it's own way of setting thresholds etc." << std::endl
              << "We keep it generic here, so the results are mediocre. You must go in and" << std::endl
              << "look up how to set the particular thresholds etc to get good results!" << std::endl
              << "--------------------------------------------------------------------------" << std::endl;
}



void processVideo(const char * videoFilename, int train) {
    // Create the capture object
    cv::VideoCapture capture = cv::VideoCapture(videoFilename);
    if (!capture.isOpened()) {
        // Error in opening the video input
        std::cerr << "Unable to open video file: " << videoFilename << std::endl;
        exit(EXIT_FAILURE);
    }
    
    // Read input data. ESC or 'q' for quitting
    double learning_rate = 0.1;
    int frame_count = 0;
    while ((char)keyboard != 'q' && (char)keyboard != 27) {
        // 1. Read the current frame
        if (!capture.read(frame)) {
            std::cerr << "Unable to read next frame." << std::endl;
            std::cerr << "Exiting..." << std::endl;
            exit(EXIT_FAILURE);
        }
        // Get frame index
        frame_count = int(capture.get(cv::CAP_PROP_POS_FRAMES));
        // Update the background model
        //
        // NOTE: This file just demonstrates the generic methods, each class
        //       Has specific ways of setting thresholds etc to make it work well.
        //       You must go into the documentation (for MOG2, see classcv_1_1BackgroundSubtractorMOG2
        //       if you want to get good results!
        // Stop learning after training，达到学习帧数后将该值设置为0，就会停止更新模型
        if (frame_count == train) {
            learning_rate = 0;
        }
        
        // 2. 训练模型，并提取前景图像
        pMOG2->apply(frame, fgMaskMOG2, learning_rate);
        // Get the frame number and write it on the current frame
        std::stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        ss << capture.get(cv::CAP_PROP_POS_FRAMES);
        std::string frameNumberString = ss.str();
        // 将帧索引绘制到提取出的图像上
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
        
        // 3. Show the current frame and the fg masks
        cv::imshow("Frame", frame);
        cv::imshow("FG Mask MOG 2", fgMaskMOG2);
        
        // 4. Get an image of the model's background
        pMOG2->getBackgroundImage(theBackground);
        imshow("theBackground", theBackground);
        
/* By uncommenting this, you can write out the mask images
        string imageToSave = "output_MOG_" + frameNumberString + ".png";
        bool saved = imwrite(imageToSave, fgMaskMOG);
        if(!saved) {
          cerr << "Unable to save " << imageToSave << endl;
        }
*/
        // Get the input from the keyboard
        if (frame_count >= train) {
            std::cout << "\nHit any key to continue\n" << std::endl;
            // Single step with keyboard press in run mode
            keyboard = cv::waitKey();
        } else {
            // Run automatically in train mode
            keyboard = cv::waitKey(10);
        }
    }
    
    // 5. Delete capture object
    capture.release();
}



void processImages(const char *fistFrameFilename, int train) {
    // 1. Read the first file of the sequence
    frame = cv::imread(fistFrameFilename);
    if (frame.empty()) {
        // Error in opening the first image
        std::cerr << "Unable to open first image frame: " << fistFrameFilename << std::endl;
        exit(EXIT_FAILURE);
    }
    // Current image filename
    std::string fn(fistFrameFilename);
    // Read input data. ESC or 'q' for quitting
    double learning_rate = 0.1;
    int frame_count = 0;
    
    while ((char)keyboard != 'q' && (char)keyboard != 27) {
        //update the background model
        //
        //NOTE: This file just demonstrates the generic methods, each class
        //      Has specific ways of setting thresholds etc to make it work well.
        //      You must go into the documentation (for MOG2, see classcv_1_1BackgroundSubtractorMOG2
        //      if you want to get good results!
        if (frame_count == train) {
            //stop learning after training
            learning_rate = 0;
        }
        
        // 2. 训练模型，并提取前景图像
        pMOG2->apply(frame, fgMaskMOG2, learning_rate);
        // get the frame number and write it on the current frame
        size_t index = fn.find_last_of("/");
        if (index == std::string::npos) {
            index = fn.find_last_of("\\");
        }
        size_t index2 = fn.find_last_of(".");
        std::string prefix = fn.substr(0, index+1);
        std::string suffix = fn.substr(index2);
        std::string frameNumberString = fn.substr(index+1, index2-index-1);
        std::istringstream iss(frameNumberString);
        int frameNumber = 0;
        iss >> frameNumber;
        rectangle(frame, cv::Point(10, 2), cv::Point(100,20),
                  cv::Scalar(255,255,255), -1);
        // 将图像索引绘制到提取出的图像上
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0,0,0));
        
        // 3. show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        
        // 4. Get an image of the model's background
        pMOG2->getBackgroundImage(theBackground);
        imshow("theBackground",theBackground);
      
/* By uncommenting this, you can write out the mask images
        string imageToSave = "output_MOG_" + frameNumberString + ".png";
        bool saved = imwrite(imageToSave, fgMaskMOG);
        if(!saved) {
          cerr << "Unable to save " << imageToSave << endl;
        }
*/
        
        //get the input from the keyboard
        if (frame_count >= train) {
            std::cout << "\nHit any key to continue\n" << std::endl;
            // Single step with keyboard press in test mode
            keyboard = cv::waitKey();
        } else {
            // Run automatically in train mode
            keyboard = cv::waitKey(10);
        }
        frame_count += 1;
        
        // 5. search for the next image in the sequence
        std::ostringstream oss;
        oss << (frameNumber + 1);
        std::string nextFrameNumberString = oss.str();
        std::string nextFrameFilename = prefix + nextFrameNumberString + suffix;
        //read the next frame
        frame = cv::imread(nextFrameFilename);
        if (frame.empty()) {
            // error in opening the next image in the sequence
            std::cerr << "Unable to open image frame: " << nextFrameFilename << std::endl;
            std::exit(EXIT_FAILURE);
        }
        // update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}



int main(int argc, const char * argv[]) {
    // print help information
    help();
    // 1. check for the input parameter correctness
    if (argc != 4) {
        std::cerr << "Incorret input list" << std::endl;
        std::cerr << "exiting..." << std::endl;
        return EXIT_FAILURE;
    }
    
    // 2. create GUI windows
    cv::namedWindow("Frame");
    cv::namedWindow("theBackground");
    cv::namedWindow("FG Mask MOG 2");

    // 3. Read the number of frames to train on
    int number_to_train_on = atoi(argv[1]);

    // 4. create Background Subtractor objects
    pMOG2 = cv::createBackgroundSubtractorMOG2();
    
    // 5. Process data
    if (strcmp(argv[2], "-vid") == 0) {
        //input data coming from a video
        processVideo(argv[3], number_to_train_on);
    } else if (strcmp(argv[2], "-img") == 0) {
        //input data coming from a sequence of images
        processImages(argv[3], number_to_train_on);
    } else {
        //error in reading input parameters
        std::cerr << "Please, check the input parameters." << std::endl;
        std::cerr << "Exiting..." << std::endl;
        return EXIT_FAILURE;
    }
    
    // 6. destroy GUI windows
    cv::destroyAllWindows();
    return EXIT_SUCCESS;
}
